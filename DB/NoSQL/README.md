## KeyDB
[KeyDB——据说是比Redis快5倍的中间件，为啥这么快](https://www.toutiao.com/a6746790632280310279)
- KeyDB使用了SO_REUSEPORT特性，多个线程可以绑定监听同个端口
- 每个worker线程做了cpu绑核，读取数据也使用了SO_INCOMING_CPU特性，指定cpu接收数据

目前windows和linux都支持对多核cpu进行调度管理

- CPU亲和性(亲和力)(affinity) 比如redis 和 nginx

所谓绑核，其实就是设定某个进程/线程与某个CPU核的亲和力（affinity）。设定以后，Linux调度器就会让这个进程/线程只在所绑定的核上面去运行。
但并不是说该进程/线程就独占这个CPU的核，其他的进程/线程还是可以在这个核上面运行的。如果想要实现某个进程/线程独占某个核，就要使用cpuset命令去实现。
其实，很多情况下，为了提高性能，Linux调度器会自动的实现尽量让某个进程/线程在同样的CPU上去运行。所以，除非必须，我们没有必要显式的去进程绑核操作。

- 如何绑核？
taskset用于将某个进程/线程绑定到CPU的某个或某几个核上面，其用法如下：
taskset -p pid
可以查出进程pid现在的绑核情况。
设置绑核有两种方法，一种是掩码形式，一种是直接绑定。下面分别介绍：
1. 掩码形式绑核
按照二进制形式，从最低位到最高位代表物理CPU的#1、#2、……、#n号核。
比如：0x00000001代表CPU的0号核，0x00000003代表CPU的0号和3号核。
需要注意的是，并非掩码中给出的CPU核就一定会存在，比如0x00000400理论上代表CPU的第10号核，但是该核在真正的计算机上面并不一定是存在的。而且，如果我们试图将物理上并不存的核绑定给某个进程时，会返回错误。掩码形式的绑核命令为：
taskset -p mask pid
2. 按CPU数直接绑核
taskset -cp cpu-list pid
其中cpu-list是数字化的cpu列表，从1开始。多个不连续的cpu可用逗号连接，连续的可用短现连接，比如1,2,5-11等。
比如“taskset -cp 1,2,5-11 9865”命令表示将进程9864绑定到#1、#2、#5~#11号核上面。


- 4.4内核为socket引入了一个SO_INCOMING_CPU选项，如果一个socket的该选项设置为n，意味着只有在n号cpu上处理协议栈逻 辑的执行流才可以将数据包插入这个socket。